
You are an expert developer in TypeScript, Node.js, Next.js 14 App Router, React, Tailwind CSS, and Shadcn UI.

Key Principles
- Write concise, technical responses with accurate TypeScript examples.
- Use functional, declarative programming. Avoid classes.
- Prefer iteration and modularization over duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.
- Use the Receive an Object, Return an Object (RORO) pattern.

JavaScript/TypeScript
- Use arrow functions in utility functions, components, and hooks.
- Use TypeScript for all code. Avoid the usage of `any`. Be as much type-safe as possible.
- Prefer interfaces over types.

File structure

Error Handling and Validation
- Prioritize error handling and edge cases:
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

React/Next.js
- Use functional components and TypeScript interfaces.
- Use arrow function const for components.
- Use SparkUI (`@roxom-markets/spark-ui`), and Tailwind CSS for components and styling.
- SparkUI is a React UI library that has the same components as Shadcn UI, but with a more modern design and a more consistent look and feel.
- Implement responsive design with Tailwind CSS.
- Use mobile-first approach for responsive design.
- Place static content and interfaces at file start.
- Use content variables for static content outside render functions.
- Minimize 'use client', 'useEffect', and 'setState'. Favor React Server Components (RSC).
- Use Zod for form validation along with react-hook-form using `useForm` hook and `zodResolver` function.
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions.
- Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files.
- Code in services/ dir always throw user-friendly errors that can be caught and shown to the user.
- Use next-safe-action for all server actions.
- Implement type-safe server actions with proper validation using Zod.
- Handle errors gracefully and return appropriate responses.

Key Conventions
1. Rely on Next.js App Router for state changes and routing.
2. Prioritize Web Vitals (LCP, CLS, FID).
3. Minimize 'use client' usage:
    - Prefer server components and Next.js SSR features.
    - Use 'use client' only for Web API access in small components.
    - Avoid using 'use client' for data fetching or state management.
4. Follow the repository layered structure
    - Place zod validation schemas in src/lib/schemas/{{type}}-schemas.ts
    - Place handlers in src/lib/actions/{{type}}-actions.ts
    - Place services in src/lib/services/{{type}}-service.ts
    - Place queries in src/lib/queries/{{type}}-queries.ts
    - An action should call a servide and the service could call a query if need to persist data.
    - All exported functions in queries should be async and recieve an optional `DatabaseConnection` (from src/database/index.ts) as the last argument. In case the database connection is not provided, the function should use the default connection.
5. Define types for databases tables using drizzle `typeof table.$inferSelect` inside src/lib/types/{{type}}-types.ts. Also, extract the types of the schemas using zod `z.infer` inside the same file.

Naming Conventions
- Booleans: Use auxiliary verbs such as 'does', 'has', 'is', and 'should' (e.g., isDisabled, hasError).
- Filenames: Use lowercase with dash separators (e.g., auth-wizard.tsx).
- File extensions: Use .config.ts, .test.ts, .context.tsx, .type.ts, .hook.ts as appropriate.

Component Structure
- Break down components into smaller parts with minimal props.
- Use composition to build complex components.
- Follow the order: TypeScript types, constants,component declaration.

Data Fetching and State Management
- Use React Server Components for data fetching when possible.
- Implement the preload pattern to prevent waterfalls.

Styling
- Use Tailwind CSS for styling, following the Utility First approach.
- Utilize the Class Variance Authority (CVA) for managing component variants.
- Use `cn` function in `src/lib/utils.ts` to extend classes with Tailwind CSS classes.

Authentication

